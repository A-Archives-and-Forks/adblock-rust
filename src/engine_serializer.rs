use crate::engine::Engine;

#[derive(Debug)]
pub enum SerializeError {
    DataFormatError(crate::data_format::SerializationError),
}

#[derive(Debug)]
pub enum DeserializeError {
    DataFormatError(crate::data_format::DeserializationError),
}

impl From<crate::data_format::SerializationError> for SerializeError {
    fn from(value: crate::data_format::SerializationError) -> Self {
        SerializeError::DataFormatError(value)
    }
}

impl From<crate::data_format::DeserializationError> for DeserializeError {
    fn from(value: crate::data_format::DeserializationError) -> Self {
        DeserializeError::DataFormatError(value)
    }
}

pub trait EngineSerializer {
    fn serialize(&self) -> Result<Vec<u8>, SerializeError>;
    fn deserialize(&mut self, serialized: &[u8]) -> Result<(), DeserializeError>;
}

impl EngineSerializer for Engine {
    /// Serializes the `Engine` into a binary format so that it can be quickly reloaded later.
    fn serialize(&self) -> Result<Vec<u8>, SerializeError> {
        use crate::data_format::SerializeFormat;

        let serialize_format = SerializeFormat::build(&self.blocker, &self.cosmetic_cache);

        let result = serialize_format.serialize()?;
        Ok(result)
    }

    /// Deserialize the `Engine` from the binary format generated by `Engine::serialize`. The
    /// method will automatically select the correct deserialization implementation.
    fn deserialize(&mut self, serialized: &[u8]) -> Result<(), DeserializeError> {
        use crate::data_format::DeserializeFormat;
        let current_tags = self.blocker.tags_enabled();
        let deserialize_format = DeserializeFormat::deserialize(serialized)?;
        let (blocker, cosmetic_cache) = deserialize_format.build();
        self.blocker = blocker;
        self.blocker
            .use_tags(&current_tags.iter().map(|s| &**s).collect::<Vec<_>>());
        self.cosmetic_cache = cosmetic_cache;
        Ok(())
    }
}
